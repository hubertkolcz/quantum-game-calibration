"""
Aggregate CSV results in Results/Quantum Server and compute confidence intervals.

Looks for files generated by bqc.py and experiments_trap.py and produces:
- summary CSVs with Wilson confidence intervals
- optional overlay plots

This script does not require NetSquid; it operates on saved results.
"""
from __future__ import annotations
import os
import glob
import math
from typing import Tuple, Optional
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt


def wilson_ci(k: float, n: float, z: float = 1.96) -> Tuple[float, float]:
    if n <= 0:
        return (float("nan"), float("nan"))
    p = k / n
    denom = 1 + z**2 / n
    center = (p + z*z/(2*n)) / denom
    margin = z * math.sqrt((p*(1-p) + z*z/(4*n)) / n) / denom
    return (max(0.0, center - margin), min(1.0, center + margin))


def _parse_num_times_from_name(name: str) -> Optional[int]:
    base = os.path.basename(name)
    if not base.endswith('.csv'):
        return None
    stem = base[:-4]
    parts = stem.split('_')
    if not parts:
        return None
    try:
        return int(parts[-1])
    except Exception:
        return None


def aggregate_bqc_results(root: str) -> pd.DataFrame:
    # bqc.py logs vary; we expect columns including succ_rate or frac0 and exec_per_sec per parameter sweep
    pattern = os.path.join(root, "Results", "Quantum Server", "results", "*.csv")
    files = glob.glob(pattern)
    rows = []
    for f in files:
        try:
            df = pd.read_csv(f)
        except Exception:
            continue
        cols = df.columns.str.lower()
        # identify available metrics
        frac0 = df["succ_rate"] if "succ_rate" in cols.values else (df["frac0"] if "frac0" in cols.values else None)
        execs = df["exec_per_sec"] if "exec_per_sec" in cols.values else None
        label = None
        for c in df.columns:
            if c not in {"id","exec_per_sec","succ_rate","succ_per_sec","m1","m2","p1","p2","frac0","frac1"}:
                label = c
                break
        if label is None:
            continue
        n = _parse_num_times_from_name(f) or float('nan')
        for _, row in df.iterrows():
            # Wilson CI if n known and fraction present
            frac = float(row.get("succ_rate", row.get("frac0", np.nan)))
            lci = uci = float('nan')
            if not (np.isnan(frac) or np.isnan(n)):
                k = round(frac * n)
                lci, uci = wilson_ci(k, n)
            rows.append({
                "file": os.path.basename(f),
                "param": label,
                "value": row[label],
                "succ_rate_or_frac0": frac,
                "exec_per_sec": float(row.get("exec_per_sec", np.nan)),
                "succ_per_sec": float(row.get("succ_per_sec", np.nan)),
                "num_times": n,
                "ci_low": lci,
                "ci_high": uci,
            })
    return pd.DataFrame(rows)


def aggregate_trap_results(root: str) -> pd.DataFrame:
    pattern = os.path.join(root, "Results", "Quantum Server", "plots", "*_trap_vs_frac.csv")
    files = glob.glob(pattern)
    rows = []
    for f in files:
        try:
            df = pd.read_csv(f)
        except Exception:
            continue
        label = None
        for c in df.columns:
            if c not in {"i","trap_succ_rate","frac0","frac1"}:
                label = c
                break
        if label is None:
            continue
        for _, row in df.iterrows():
            rows.append({
                "file": os.path.basename(f),
                "param": label,
                "value": row[label],
                "trap_succ_rate": float(row.get("trap_succ_rate", np.nan)),
                "frac0": float(row.get("frac0", np.nan)),
            })
    return pd.DataFrame(rows)


def main() -> None:
    root = os.getcwd()
    out_dir = os.path.join(root, "Results", "Quantum Server", "summary")
    os.makedirs(out_dir, exist_ok=True)

    bqc_df = aggregate_bqc_results(root)
    if not bqc_df.empty:
        bqc_df.to_csv(os.path.join(out_dir, "bqc_sweeps_flat.csv"), index=False)
        # simple scatter: param vs succ_per_sec if present
        for param in sorted(bqc_df["param"].unique()):
            sub = bqc_df[bqc_df["param"] == param]
            if sub["succ_per_sec"].notna().any():
                plt.figure(figsize=(8,5))
                plt.plot(sub["value"], sub["succ_per_sec"], marker='o')
                plt.xlabel(param)
                plt.ylabel("Successes per second")
                plt.title(f"BQC: {param} vs successes/sec")
                plt.tight_layout()
                plt.savefig(os.path.join(out_dir, f"bqc_{param}_succ_per_sec.png"))
                plt.close()

    trap_df = aggregate_trap_results(root)
    if not trap_df.empty:
        trap_df.to_csv(os.path.join(out_dir, "trap_vs_frac_flat.csv"), index=False)
        # overlay
        for param in sorted(trap_df["param"].unique()):
            sub = trap_df[trap_df["param"] == param]
            plt.figure(figsize=(8,5))
            plt.plot(sub["value"], sub["trap_succ_rate"], label="trap success")
            plt.plot(sub["value"], sub["frac0"], label="P(m2=0)")
            plt.xlabel(param)
            plt.ylabel("Probability")
            plt.title(f"Trap success vs P(m2=0): {param}")
            plt.legend()
            plt.tight_layout()
            plt.savefig(os.path.join(out_dir, f"trap_{param}_overlay.png"))
            plt.close()

    print(f"Wrote summaries to {out_dir}")


if __name__ == "__main__":
    main()
